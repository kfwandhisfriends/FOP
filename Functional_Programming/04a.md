ä¼ ç»ŸOOP:
1. å¾…å®ç°çš„åŠŸèƒ½ wird in class und interface zerlegt;
2. Konzept = classes + interfaces;
3. Program Ablauf = interaktion von objects;
4. Durch Vererbung kann ein Konzept(class or interface) ein anderes erweitern, verfeinern oder variieren;
    -- å­ç±»çš„objectæ°¸è¿œå¯ä»¥æ›¿ä»£çˆ¶ç±»çš„ä½ç½® -> å­ç±»ä¸€å®šæ˜¯ä¸€ä¸ªçˆ¶ç±»


Functional Abstraction
======================
1. å‡½æ•°æ˜¯zentralen Bausteine;
    - f: D1 * D2 .... Dn -> R
2. ç¨‹åºè®¾è®¡:
    - å¾…å®ç°çš„åŠŸèƒ½è¢«åˆ†è§£æˆå‡½æ•°;
    - å‡½æ•°ä¹‹é—´ç›¸äº’è°ƒç”¨;
3. å‡½æ•°æ ¹æ®å‚æ•°çš„ä¸åŒè€Œå¼‚;
   - ä¸€ä¸ªå‡½æ•°å—åˆ¶äºå¦ä¸€ä¸ªå‡½æ•°çš„è¿”å›å€¼ã€‚

Deklaratives Programming
=========================
**åŸºæœ¬æ€æƒ³:**
- ä¸å†™ die Befehlen, die ausgefuehrt werdeb sollen, BUT: die FORMEL fuer das Ergebnis;

**Consequence:**
- æ— æ—¶é—´é¡ºåº -> å‡½æ•°çš„å‚æ•°ç›¸åŒï¼Œåˆ™æ— è®ºä½•æ—¶è°ƒç”¨ï¼Œç»“æœæ€»æ˜¯ç›¸åŒçš„ã€‚
- å‡è®¾æœ‰ä¸€ä¸ª `add(x, y)`ã€‚åœ¨è°ƒç”¨ `add(3, 5)` æ—¶ï¼Œå…¶ç»“æœæ˜¯8ã€‚åœ¨ç¨‹åºçš„å…¶ä»–åœ°æ–¹ï¼Œ`add(3, 5)` å’Œ `8` æ˜¯ç­‰ä»·çš„ï¼Œå¯ä»¥äº’ç›¸æ›¿æ¢ï¼Œå› ä¸ºâ€”â€”å‡½æ•°æ²¡æœ‰å‰¯ä½œç”¨ã€‚åœ¨FPä¸­ï¼Œå‡½æ•°çš„ç»“æœä»…å–å†³äºè¾“å…¥å‚æ•°ï¼Œä¸ä¾èµ–äºå…¶ä»–å¤–éƒ¨çŠ¶æ€æˆ–ä¸Šä¸‹æ–‡ã€‚è¿™è¢«ç§°ä¸ºå¼•ç”¨é€æ˜æ€§ã€‚
-  ç›¸åŒçš„è¡¨è¾¾å¼ -> ä¸åŒçš„è¾“å‡º
```java
  int n = 10;
  System.out.println(n); //10
  int n = 11;
  System.out.println(n); //11
```
    
```java
X x = new Y();
x.m();
x = new Z();
x.m()
```

æ— å¯¹è±¡èº«ä»½ -> åœ¨OOPä¸­ï¼Œæ¯ä¸ªå¯¹è±¡éƒ½æœ‰ä¸€ä¸ªå”¯ä¸€çš„æ ‡è¯†ç¬¦ï¼Œå³ä½¿å…¶çŠ¶æ€/å±æ€§å˜åŒ–ï¼Œæ ‡è¯†ç¬¦ä¹Ÿä¸å˜ã€‚->ä¸¤ä¸ªå¯¹è±¡å¿…é¡»å…·æœ‰ç›¸åŒçš„æ ‡è¯†ç¬¦æ‰èƒ½è¢«è®¤ä¸ºæ˜¯ç›¸åŒçš„å¯¹è±¡ã€‚Keine Object Identitaet å¼ºè°ƒå¯¹è±¡çš„èº«ä»½ä¸é‡è¦ã€‚


Racket syntax
=====
```java
public class A{
    public static BigDecimal add(BigDecimal x, BigDecimal y){
        return x.add(y);
    }
}
```

```scheme
(define (add x y) (+ x y))
        name Para  æ•ˆæœ
```
[define]ç”¨äºå®šä¹‰ 1. konstanteâ¬‡ 2. function
-----
```java
public class Math{
    ...
    public static final double PI = 3.14159;
    ...
}
```

```scheme
(define my-pi 3.14159)   ;pi ist vordefiniert       
```

boolsche Operationen
--------
```scheme
(= x1 x2 x3)    ;(and(= x1 x2) (= x2 x3))
(< x1 x2 x3)    ;(and(< x1 x2) (< x2 x3))
(<= x1 x2 x3)    ;(and(<= x1 x2) (<= x2 x3))
```

if-Verzweigung
-------------
```scheme
(define (my-abs x) (if (< 0 x) x -x)) ; if 0<x -> -x, else x
(define (my-max x y) (if(< x y) y x))
(define (diff-is-integral x y) (if(integer? (- x y) #t #f))) ;!!!ä¸åŒäºjavaï¼Œ è¿™é‡Œä¸åœ¨ä¹formale Para,åªè¦Diffæ˜¯ä¸€ä¸ªæ•´æ•°å°±è¿”å›true;
æŠŠ ifç†è§£æˆ ä¸‰ä¸ªParaçš„function - ç¬¬ä¸€ä¸ªparaå¿…é¡»æ˜¯boolesch
```
ä½†æ˜¯ç¬¬äºŒä¸ªå’Œç¬¬ä¸‰ä¸ªParaç±»å‹å¯ä»¥ä¸åŒ
``` scheme
((define (positive-or-string x)
  (if (> x 0)
      1
      "x is not a positive number")))
```


Typ einer Funktion
---------
```scheme
;;Type: number number -> number
;;
;;Returns: the sum of the 2 Paras
ğŸ‘† -> Vertrag, å³å¥‘çº¦ã€‚ å¦‚æœè°ƒç”¨è€…å±¥è¡Œå¥‘çº¦éƒ¨åˆ†(ä¸¤ä¸ªParaéƒ½æ˜¯number)ï¼Œ é‚£ä¹ˆå‡½æ•°å±¥è¡Œå…¶å¥‘çº¦ï¼Œ å³è¿”å›æ€»å’Œ

(define (add x y)(+ x y))
```

ä¸ifä¸åœ¨ä¹ç¬¬äºŒç¬¬ä¸‰Paraç»“åˆï¼š
```scheme
(define (positive-or-string x)
  (if (> x 0)
      1
      "x is not a positive number"))
     
(define (my_add x y) (+ x y))

(displayln (my_add 5 (positive-or-string 5)))

OUTPUT: 6

;;BUT if the para in Posit_function is <=0, which makes posit_function return a String, then
OUTPUT: +: contract violation
        expected: number?
        given: "x is not a positive number"

```

Laufzeit check
-----------
å¯ä»¥åœ¨è¿è¡Œæ—¶æ£€æŸ¥functionæ­£ç¡®æ€§:
``` scheme
;;Type: number number -> number
;;!! Precondition: the second para must be not zero
;;Returns: the sum of the 2 Paras

( define (divide x y) (/ x y))

( check-expect (divide 15 3) 5)
( check-within (divide pi e) 1.15 0.01) ;ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯é¢„ä¼°å€¼ï¼Œ ç¬¬äºŒä¸ªæ˜¯ è¯¯å·®+-
( check-error (divide 15 0) "/: division by zero") ; å¦‚æœç¬¬ä¸€ä¸ªå‚æ•°(divide 15 0)è¿”å›äº†é”™è¯¯ï¼Œä¸”è¯¥é”™è¯¯ä¸ç¬¬äºŒä¸ªå‚æ•°ç›¸åŒï¼Œ é‚£ä¹ˆæµ‹è¯•æˆåŠŸ.
```

å‡½æ•°ä¸­å†…ç½®æµ‹è¯•ï¼š  
```scheme
(define (divide x y))
    (if ( = y 0) (error"Division by 0") ( / x y))
                ; vordefinierte Function [error], erroråé¢çš„å‚æ•°å¿…é¡»æ˜¯ä¸€ä¸ªString;
                ; å¦‚æœy=0, æ‰“æ–­ï¼Œ æŠ¥é”™
```

Definition verstecken å®šä¹‰ä¸å¯è§æ€§
-----------------
``` scheme 
;; fct: number -> number
(define (fct x)
    (local
    ( (define const 10)
      (define (mult-const y) (* const y)))  ;localé‡Œdefineçš„wert, functionåªèƒ½åœ¨localå—é‡Œç”¨
    (+ const (mult-const x))  ))            ; const + (mult-const x) æ˜¯æ•´ä¸ªlocal å—çš„å€¼
```
å¸¸é‡ const å’Œå‡½æ•° mult-const ä»…åœ¨ localåŒºå—é‡Œå¯è§   
localé‡Œçš„defineåŒºåŸŸç”¨é¢å¤–çš„ï¼ˆï¼‰å¯¹ åŒ…å›´


Rekursion in Racket
===========
```java
public static int factorial (int n){
    return n==0? 1: n * factorial(n-1);
}
```

```scheme
;;Type: natural -> natural 
( define ( factorial n)
    (if ( = n 0) 
        1 
        (* n ( factorial(- n 1)))
    )
)

;Test:
( factorial 4 )
( * 4 ( factorial 3 ) )
( * 4 ( * 3 ( factorial 2 ) ) )
( * 4 ( * 3 ( * 2 ( factorial 1 ) ) ) )
( * 4 ( * 3 ( * 2 ( * 1 ( factorial 0 ) ) ) ) )
( * 4 ( * 3 ( * 2 ( * 1 1 ) ) ) )
( * 4 ( * 3 ( * 2 1 ) ) )
( * 4 ( * 3 2 ) )
( * 4 6 )
```



